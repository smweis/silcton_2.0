# -*- coding: utf-8 -*-
"""
Created on Mon Feb 17 10:53:55 2020

@author: stevenweisberg


This script will take as input the text file generated by the Silcton Standalone
pointing task and output a csv file with the data coded for angular error.

To run this, put your output text files in the same folder as this script. By default
the standalone file will output the text files into ~/Documents (PC) or ~/home directory
for Macs.

Then, open your favorite Python IDE (I recommend Anaconda's implementation of Spyder)
and run this script. You should see [standalone_data_output.csv] in your working directory.


"""
import datetime
import pandas as pd
import numpy as np
import os

# Get all text files within a working directory.
workingDir = os.getcwd()
dirFiles = os.listdir()
fileNames = [x for x in dirFiles if 'txt' in x]
fullFileNames = []
for i in fileNames:
    fullFileNames.append(workingDir + os.path.sep + i)


# This section of code will re-calculate the angles from the original coordinates

# from seeds.rb on website (original coordinates, negative Y)
# Note - there was an irregularity in the website where the Y-values were POSITIVE.
# These have been changed to negative to allow for proper angle calculations.
# This made no difference in the original trigonometry, but must be adjusted now.

buildingNamesOnce = ['Batty House','Lynch Station','Harris Hall','Harvey House',
'Golledge Hall','Snow Church','Sauer Center','Tobler Museum']

buildingNames = [buildingNamesOnce,buildingNamesOnce]
index = pd.MultiIndex.from_product(buildingNames,names=['Pointing_From','Pointing_To'])

data = {'Batty House': [0,63,-292,91,-309],
        'Lynch Station':[1,67,-169,158,-222],
        'Harris Hall':[2,268,-262,284,-251],
        'Harvey House':[3,310,-498,300,-488],
        'Golledge Hall':[4,635,-303,628,-255],
        'Snow Church':[5,731,-262,692,-258],
        'Sauer Center':[6,683,-69,687,-141],
        'Tobler Museum':[7,536,-189,536,-197]}

pd.DataFrame.from_dict(data, orient='index',
                       columns=['visit_order',
                       'front_door_pixel_x',
                       'front_door_pixel_y',
                       'pointing_location_pixel_x',
                       'pointing_location_pixel_y'])



def vectorSubtraction(point_from,target,facing):
    #vector subtraction logic from here:
    #https://stackoverflow.com/questions/21483999/using-atan2-to-find-angle-between-two-vectors
    vector1 = np.subtract(facing,point_from) # center the facing and target points
    vector2 = np.subtract(target,point_from)
    # Now calculate the signed angle between them as the difference between arctans (y,x)
    angle = np.arctan2(vector1[1],vector1[0]) - np.arctan2(vector2[1],vector2[0])
    angle = np.rad2deg(angle)

    # Correct for being the wrong side of 180
    if angle > 180:
        correctedAngle = angle - 360
    elif angle < -180:
        correctedAngle = 360 + angle
    else:
        correctedAngle = angle

    return correctedAngle



recalculatedAnswers = []

# This loop goes through each landmark and calculates the pointing error.
for i,j in enumerate(landmarks_df.index):
    # if the point_from location is at the end of the route
    # the facing direction is toward the previous diamond
    # otherwise it's toward the next diamond
    if i in (3,7):
        face = i - 1
    else:
        face = i + 1

    # Create two 2D vectors,
    # point_from = the point for the landmark that judgment was made from
    # facing = the point of the gem for the facing landmark.
    point_from = [landmarks_df['pointing_location_pixel_x'][j],landmarks_df['pointing_location_pixel_y'][j]]
    facing = [landmarks_df['pointing_location_pixel_x'][face],landmarks_df['pointing_location_pixel_y'][face]]

    # Loop through each landmark, skipping if the landmark is the one that trial was made from.
    for x,y in enumerate(landmarks_df.index):
        if x == i:
            value = np.nan
        else:
            target = [landmarks_df['front_door_pixel_x'][y],landmarks_df['front_door_pixel_y'][y]]
            value= vectorSubtraction(point_from,target,facing)

        recalculatedAnswers.append(value)



# The unsigned answers.
unsignedAnswers = [np.nan,47.32798389,37.5286373,93.19423766,51.76768154,48.19947553,30.3316951,37.30802198,
		   130.6542463,np.nan,7.021704671,48.19593801,3.323863738,8.968174613,29.20903342,17.95076442,
		   83.35216568,114.5627943,np.nan,2.146796904,77.71082192,84.7281122,110.6574336,99.95984558,
		   46.54689912,32.28246429,4.196894849,np.nan,64.9530254,66.19140238,46.29205396,42.14615863,
		   173.5694617,173.9683139,176.2022806,139.9309368,np.nan,1.204134401,76.21088344,147.0284471,
		   90.64700942,79.44851915,88.09346154,119.6929579,125.8431145,np.nan,0.279262352,63.69277617,
		   6.744508622,17.76205492,4.240040564,23.09134403,51.85616181,89.63525726,np.nan,2.713388186,
		   171.0086651,156.2355625,173.2852643,147.248191,67.30353066,38.78279809,20.69981416,np.nan]

df = pd.DataFrame(unsignedAnswers, index=index, columns=['unsignedAnswer'])

df['recalculatedAnswer'] = recalculatedAnswers
df['participantAngle'] = np.nan
df['pointOrder'] = np.nan

def pointingCalculationGood(actual,guess):
    diff = abs(actual - guess)
    if diff > 180:
        diff = 360-diff
    return diff

def pointingCalculationBad(actual,guess):
    guess = abs(guess)
    actual = abs(actual)
    diff = abs(actual - guess)
    if diff > 180:
        diff = 360-diff
    return diff


#open input file, read as data
for i,j in enumerate(fullFileNames):
    with open (j, "r") as myfile:
        participantData = pd.read_csv(myfile)


    for index,row in participantData.iterrows():
        pointFrom = row['pointingDiamondIndex']
        pointTo = row['targetBuildingIndex']
        df.loc[(pointFrom,pointTo)]['participantAngle'] = row['pointingAngle']
        df.loc[(pointFrom,pointTo)]['pointOrder'] = index
    df['correctAngularError'] = [pointingCalculationGood(x,y) for x, y in zip(df['recalculatedAnswer'], df['participantAngle'])]
    df['DO_NOT_USE_incorrectAngularError'] = [pointingCalculationBad(x,y) for x, y in zip(df['unsignedAnswer'], df['participantAngle'])]

    to_save_name = workingDir+os.path.sep+'output_'+fileNames[i][:-4]+'.csv'

    if os.path.isfile(to_save_name):
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d-%H%M%S")
        to_save_name = workingDir+os.path.sep+'output_'+fileNames[i][:-4]+'_'+timestamp+'.csv'

    df.to_csv(to_save_name)
